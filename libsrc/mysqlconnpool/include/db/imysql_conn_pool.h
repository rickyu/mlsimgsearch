/** 
 * \file imysql_conn_pool.h
 * \brief the interface of mysql conn pool
 * \author sjcui
 * \date 2009-08-26
 * Copyright (C) Baidu Company
 */

#ifndef _APP_GENSOFT_DIALOG_SERVER_LIBSRC_DB_IMYSQL_CONN_POOL_H_
#define _APP_GENSOFT_DIALOG_SERVER_LIBSRC_DB_IMYSQL_CONN_POOL_H_
#include <mysql.h>
#include <string>
#include <vector>
#include "utils/iref.h"
#include "imysql_conn.h"

namespace db{

/// implement in mysql_conn_pool.cpp
std::string GetConf( SMysqlConf mysqlConf, uint32_t conns, bool isDefault );

/*
 * 连接工厂
 * */
class IMysqlConnPool :
    public IRef
{
public:
    virtual ~IMysqlConnPool() = 0;

    /** 
     * \brief Start
     *   start the maintain thread of this pool
     *   MUST be called before use
     */
    virtual void Start() = 0;
    /** 
     * \brief Stop
     *    stop the maintain thread of this pool
     *    MUST be called before delete 
     */
    virtual void Stop() = 0;
    
    /** 
     * \brief AddDefault        thread SAFE
     *    add a config for mysql to generate some connection,
     *   the connections are marked with "default"
     * 
     * \param mysqlConf         [in] the mysql conf
     * \param conns             [in] the number of connections
     * 
     * \return the connections which are generated by the pool
     */
    virtual std::vector< IMysqlConn* > AddDefault( SMysqlConf mysqlConf, uint32_t conns ) = 0;
    /** 
     * \brief AddDBServer       thread SAFE
     *    add a config for mysql to generate some connection,
     *   the connections are marked with non-"default"
     * 
     * \param mysqlConf         [in] the mysql conf
     * \param conns             [in] the number of connections
     * 
     * \return the connections which are generated by the pool
     */
    virtual std::vector< IMysqlConn* > AddDBServer( SMysqlConf mysqlConf, uint32_t conns ) = 0;

    /** 
     * \brief DelServer         thread SAFE
     *   delete a mysql conf from the pool
     * 
     * \param conf              [in] the mysql conf
     */
    virtual void DelServer( std::string conf ) = 0;

    /** 
     * \brief SetTimeout        thread SAFE
     *      set the default timeout conf-value of GetConn operation
     * 
     * \param ms    [in] the conf-value to set
     * 
     * \return old-version default timeout conf-value of GetConn operation.
     *         0 for 1st call of this function
     */
    virtual uint32_t SetTimeout(uint32_t ms) = 0;

    /** 
     * \brief IsAvailable       thread SAFE
     *      see if there are available connections in the pool
     * 
     * \return true for yes, false otherwise
     */
    virtual bool IsAvailable() const = 0;

    /** 
     * \brief GetConn   thread SAFE
     *     get a connection from the pool. this will cause conn->AddRef()
     *     DONT delete the connection directly, use FreeConn instead
     * 
     * \param ms        [in] timeout value
     * 
     * \return a pointer to connection if success, otherwise return NULL
     */
    virtual IMysqlConn* GetConn(uint32_t ms = 0) = 0;

    /** 
     * \brief FreeConn  thread SAFE
     *    free a connection to the pool
     *    this will cause conn->Release()
     * 
     * \param conn      [in] the connection to be freed 
     */
    virtual void FreeConn(IMysqlConn* conn) = 0;

    /** 
     * \brief GetAvailNum
     *    get the number of currently available connection
     * 
     * \return  the number of connection
     */
    virtual uint32_t GetAvailNum() const = 0;
};

/*
 * 以引用计数的方式封装连接工厂
 * 在动态替换连接工厂时，实现连接的平滑迁移
 * */
class IMysqlRefPoolUnit :
    public IRef
{
public:
    virtual ~IMysqlRefPoolUnit() = 0;
    /** 
     * \brief Init          execute ONCE
     *   associate the ref-pool with mysql-conn-pool
     * 
     * \param pool          [in] the mysql conn pool
     * \param addRef        [in] whether do an AddRef to 
     *                              \param pool 
     */
    virtual void Init( IMysqlConnPool* pool, bool addRef = true ) = 0;
    /** 
     * \brief AddServer     thread SAFE
     *   add a conf into the ref-pool
     * 
     * \param mysqlConf     [in] the mysql conf
     * \param conns         [in] the number of connections
     * \param isDefault     [in] the mark of connections
     */
    virtual void AddServer( SMysqlConf mysqlConf, uint32_t conns, bool isDefault ) = 0;
    
    /** 
     * \brief GetConn       thread SAFE
     *     get a connection from the pool.
     *     DONT delete the connection directly, use FreeConn instead
     * 
     * \param ms        [in] timeout value
     * 
     * \return a pointer to connection if success, otherwise return NULL
     */
    virtual IMysqlConn* GetConn( uint32_t ms = 0 ) = 0;
    /** 
     * \brief FreeConn      thread SAFE
     *    put a connection back into pool
     *    NOTE: connections which were not gotten from this ref-pool,
     *    may be freed into this ref-pool, as long as the 2 related ref-pool
     *    shared with ONE CMysqlConnPool.
     *    TODO: shall we add some thing to the connection, so that we can
     *    check which pool it come from?
     * 
     * \param conn      [in] the connection which was gotten from some ref-pool
     */
    virtual void FreeConn(IMysqlConn* conn) = 0;
    /** 
     * \brief SetTimeout        thread SAFE
     *      set the default timeout conf-value of GetConn operation
     * 
     * \param ms    [in] the conf-value to set
     * 
     * \return old-version default timeout conf-value of GetConn operation.
     *         0 for 1st call of this function
     */
    virtual uint32_t SetTimeout(uint32_t ms) = 0;

    /** 
     * \brief IsAvailable       thread SAFE
     *      see if there are available connections in the pool
     * 
     * \return true for yes, false otherwise
     */
    virtual bool IsAvailable() const = 0;
};

/*
 * 提供动态替换IMysqlRefPoolUnit的能力，本身不可动态替换
 * */
class IMysqlRefPool :
    public IRef
{
public:
    virtual ~IMysqlRefPool() = 0;
    
    /** 
     * \brief Init  execute ONCE
     *   load a refPoolUnit into refPool
     * 
     * \param refPoolUnit       [in] the ref-pool unit
     * \param addRef            [in] whether do an AddRef to 
     *                              \param refPoolUnit
     */
    virtual void Init( IMysqlRefPoolUnit* refPoolUnit, bool addRef = true ) = 0;
    /** 
     * \brief Get   thread SAFE
     *      get the currently used IMysqlRefPoolUnit
     *    It is an atomic operation, so wont conflict with Set()
     *    NOTE:
     *      the returning pointer to IMysqlRefPoolUnit SHALL 
     *    do a Release()
     * 
     * \return the currently used IMysqlRefPoolUnit
     */
    virtual IMysqlRefPoolUnit* Get() = 0;
   /** 
    * \brief Set    execute in SINGLE thread 
    *       replace the currently used IMysqlRefPoolUnit
    *    It is an atomic operation
    *    NOTE:
    *       if exists, the old IMysqlRefPoolUnit will do a Release(),
    * 
    * \param refPool        [in] new ref pool
    */
    virtual void Set( IMysqlRefPoolUnit*, bool addRef = true ) = 0;
};

/*
 * 管理IMysqlRefPool的号段信息和读写能力。
 * PoolDesc指定的对应关系不可动态改变
 * */
class IMysqlPoolMgr :
    public IRef
{
public:
    virtual ~IMysqlPoolMgr() = 0;
    struct PoolDesc
    {
        IMysqlRefPool* pRefPool;
        /// POOL_READ | POOL_WRITE
        uint32_t rw;
        uint64_t segmentLo;
        uint64_t segmentHi;
    };

    enum
    {
        POOL_READ = 0x1,
        POOL_WRITE = 0x2
    };

    virtual void Init( const PoolDesc* pools, uint32_t count, bool addRef = true ) = 0;
    virtual IMysqlRefPoolUnit* Get( uint32_t rw, uint64_t key ) = 0;
    virtual IMysqlRefPool* GetPool( uint32_t rw, uint64_t key ) = 0;
    /** 
     * \brief GetSampleKey
     *   获得针对PoolMgr内各mysql的样例key
     * 
     * \param rw        [in] 指定mysql的读写类型
     * \param key       [in] 预先分配的结果数组指针，若为NULL，则返回应分配数组的大小
     * \param count     [in] 结果数组的大小
     * 
     * \return      若\param key == NULL 则返回结果数组的理论大小
     *              否则返回结果数组的实际大小
     *              出错返回-1
     */
    virtual int32_t GetSampleKey( uint32_t rw, uint64_t* key, uint32_t count ) = 0;
};

}//end of namespace db
#endif

